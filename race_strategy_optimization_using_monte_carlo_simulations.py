# -*- coding: utf-8 -*-
"""Race Strategy Optimization using Monte Carlo Simulations.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1IoPp-C4lDrdxEjWB07trW9PSSVK1NRRz
"""

import sys
import math
import time
import pandas as pd
import numpy as np
from prettytable import PrettyTable
import multiprocessing as mp
from concurrent.futures import ProcessPoolExecutor, as_completed
from functools import partial
import matplotlib.pyplot as plt
from itertools import repeat


def print_banner():
    """Print program banner"""
    print("*************************** Race Strategy Optimizer *************************")
    print("*************    Monte Carlo Strategy Simulator (Parallel)    *************")
    print("*************              Version 2.0.0: 2024              **************")
    print("************************************************************************")
    print("*************************** Strategy Options ****************************")
    print("* One Stop     | Two Stop      | Three Stop        | No Stop          *")
    print("* Soft-Medium  | Soft-Soft-Med | Soft-Soft-Soft-M | Hard             *")
    print("* Medium-Hard  | Med-Med-Hard  | Med-Med-Med-H    |                  *")
    print("************************************************************************")


def analyze_results(results):
    """Vectorized results analysis"""
    results_array = np.array([(r['total_time'], r['position'], r['tire_deg'], r['fuel_used'])
                              for r in results])

    return {
        'avg_race_time': np.mean(results_array[:, 0]),
        'avg_position': np.mean(results_array[:, 1]),
        'avg_tire_deg': np.mean(results_array[:, 2]),
        'avg_fuel_used': np.mean(results_array[:, 3]),
        'race_times': results_array[:, 0]
    }


def create_comparison_plots(serial_results, parallel_results, serial_time, parallel_time, num_processes):
    """Create comparison visualizations using matplotlib"""
    plt.style.use('default')

    plt.rcParams['figure.figsize'] = [15, 10]
    plt.rcParams['axes.grid'] = True
    plt.rcParams['axes.axisbelow'] = True
    plt.rcParams['grid.linestyle'] = '--'
    plt.rcParams['grid.alpha'] = 0.5

    fig = plt.figure()

    # Race time distribution comparison
    ax1 = plt.subplot(2, 2, 1)
    ax1.hist(serial_results['race_times'], bins=50, alpha=0.5, label='Serial', color='royalblue')
    ax1.hist(parallel_results['race_times'], bins=50, alpha=0.5, label='Parallel', color='crimson')
    ax1.set_title('Race Time Distribution Comparison', pad=10)
    ax1.set_xlabel('Total Race Time (seconds)')
    ax1.set_ylabel('Frequency')
    ax1.legend()

    # Processing time comparison
    ax2 = plt.subplot(2, 2, 2)
    bars = ax2.bar(['Serial', 'Parallel'], [serial_time, parallel_time])
    bars[0].set_color('royalblue')
    bars[1].set_color('crimson')
    ax2.set_title('Processing Time Comparison', pad=10)
    ax2.set_ylabel('Time (seconds)')


    plt.tight_layout()
    return fig


def simulate_race_batch(params):
    """Simulate multiple races at once for better performance"""
    batch_size, strategy_params, start_seed = params
    results = []

    # Pre-generate all random values for the batch
    np.random.seed(start_seed)
    input_strategy, input_tire_sequence, input_baseline_lap_time, input_race_laps, input_pit_loss = strategy_params

    # Generate random values in bulk for the entire batch
    tire_deg_factors = np.random.normal(0.1, 0.02, (batch_size, input_race_laps))
    fuel_penalties = np.random.normal(0.05, 0.01, (batch_size, input_race_laps))
    positions = np.random.randint(1, 20, batch_size)

    # Pre-calculate pit stop effects
    pit_laps = {
        "Two Stop": [20, 40],
        "Three Stop": [15, 30, 45],
        "One Stop": [30],
        "No Stop": []
    }.get(input_strategy, [])

    # Create base arrays for vectorized operations
    lap_times = np.full((batch_size, input_race_laps), input_baseline_lap_time)
    tire_life = np.tile(np.arange(input_race_laps), (batch_size, 1))

    # Apply pit stops
    for pit_lap in pit_laps:
        tire_life[:, pit_lap:] -= pit_lap + 1
        lap_times[:, pit_lap] += input_pit_loss

    # Vectorized calculations for entire batch
    fuel_load = 100 - (np.arange(input_race_laps) * (100 / input_race_laps))
    fuel_load = np.tile(fuel_load, (batch_size, 1))

    tire_effect = tire_life * tire_deg_factors
    fuel_effect = fuel_load * fuel_penalties

    # Calculate total times for all simulations in batch
    total_times = np.sum(lap_times + tire_effect + fuel_effect, axis=1)
    final_tire_degs = tire_effect[:, -1]
    final_fuels = 100 - fuel_load[:, -1]

    # Create results for each simulation in batch
    for i in range(batch_size):
        results.append({
            'total_time': total_times[i],
            'tire_deg': final_tire_degs[i],
            'fuel_used': final_fuels[i],
            'position': positions[i]
        })

    return results


def run_parallel_simulation(num_simulations, strategy_params, num_processes):
    """Improved parallel simulation with optimized batching"""
    start_time = time.time()

    # Dynamically calculate the optimal batch size based on available processes and simulation count
    batch_size = max(500, num_simulations // (num_processes * 3))  # Lower batch size for higher parallel efficiency
    num_batches = (num_simulations + batch_size - 1) // batch_size

    # Prepare batch parameters
    batch_params = [
        (min(batch_size, num_simulations - i * batch_size),
         strategy_params,
         i * batch_size)
        for i in range(num_batches)
    ]

    results = []
    with ProcessPoolExecutor(max_workers=num_processes) as executor:
        # Submit tasks asynchronously to improve parallel efficiency
        futures = {executor.submit(simulate_race_batch, params): params for params in batch_params}

        for future in as_completed(futures):
            batch_results = future.result()
            results.extend(batch_results)

    end_time = time.time()
    return results[:num_simulations], end_time - start_time


def run_serial_simulation(num_simulations, strategy_params):
    """Optimized serial simulation using batching"""
    start_time = time.time()
    batch_size = 200000  # Efficient batch size for serial processing
    results = simulate_race_batch((batch_size, strategy_params, 0))
    end_time = time.time()
    return results[:num_simulations], end_time - start_time


def main():
    print_banner()

    # Optimize process count based on simulation size
    num_simulations = 20000
    num_processes = min(mp.cpu_count(), max(2, num_simulations // 1000))

    if input("* Keyboard or csv: ").lower() == "keyboard":
        # Get strategy inputs
        input_strategy = input("* Add strategy (e.g., 'Two Stop'): ")
        input_tire_sequence = input("* Add tire sequence (e.g., 'Soft-Soft-Med'): ")
        input_baseline_lap_time = float(input("* Add baseline lap time (seconds): "))
        input_race_laps = int(input("* Add total race laps: "))
        input_pit_loss = float(input("* Add pit stop time loss (seconds): "))

        strategy_params = (input_strategy, input_tire_sequence, input_baseline_lap_time,
                           input_race_laps, input_pit_loss)

        # Run simulations with progress indication
        print(f"\nRunning simulations with {num_processes} processes...")

        serial_results, serial_time = run_serial_simulation(num_simulations, strategy_params)
        print("Serial simulation completed...")

        parallel_results, parallel_time = run_parallel_simulation(
            num_simulations, strategy_params, num_processes)
        print("Parallel simulation completed...")

        # Analyze and display results
        serial_analysis = analyze_results(serial_results)
        parallel_analysis = analyze_results(parallel_results)

        # Print race time, tire degradation, and fuel usage
        print("\n*************** RACE STRATEGY PERFORMANCE ***************")
        print(f"Serial Race Time (Average): {serial_analysis['avg_race_time']:.2f} seconds")
        print(f"Parallel Race Time (Average): {parallel_analysis['avg_race_time']:.2f} seconds")
        print(f"Serial Tire Degradation (Average): {serial_analysis['avg_tire_deg']:.2f}%")
        print(f"Parallel Tire Degradation (Average): {parallel_analysis['avg_tire_deg']:.2f}%")
        print(f"Serial Fuel Usage (Average): {serial_analysis['avg_fuel_used']:.2f}%")
        print(f"Parallel Fuel Usage (Average): {parallel_analysis['avg_fuel_used']:.2f}%")

        # Create comparison plots
        fig = create_comparison_plots(
            serial_analysis, parallel_analysis, serial_time, parallel_time, num_processes)

        # Print performance metrics
        print("\n*************** PERFORMANCE COMPARISON ***************")
        print(f"Serial Processing Time: {serial_time:.2f} seconds")
        print(f"Parallel Processing Time: {parallel_time:.2f} seconds")
        print(f"Speedup: {(serial_time / parallel_time):.2f}x")
        print(f"Efficiency: {(serial_time / parallel_time / num_processes):.2f}")

        plt.show()

    else:
        print("CSV input option not implemented in this version")
        sys.exit()


if __name__ == "__main__":
    main()